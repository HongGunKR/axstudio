{
  "data": {
    "edges": [
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "URLComponent",
            "id": "URLComponent-NmMF1",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "CoEModelPicker-BE6sX",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__URLComponent-NmMF1{œdataTypeœ:œURLComponentœ,œidœ:œURLComponent-NmMF1œ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-CoEModelPicker-BE6sX{œfieldNameœ:œtoolsœ,œidœ:œCoEModelPicker-BE6sXœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "URLComponent-NmMF1",
        "sourceHandle": "{œdataTypeœ:œURLComponentœ,œidœ:œURLComponent-NmMF1œ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "CoEModelPicker-BE6sX",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œCoEModelPicker-BE6sXœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "CalculatorComponent",
            "id": "CalculatorComponent-fBWEK",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "CoEModelPicker-BE6sX",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CalculatorComponent-fBWEK{œdataTypeœ:œCalculatorComponentœ,œidœ:œCalculatorComponent-fBWEKœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-CoEModelPicker-BE6sX{œfieldNameœ:œtoolsœ,œidœ:œCoEModelPicker-BE6sXœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CalculatorComponent-fBWEK",
        "sourceHandle": "{œdataTypeœ:œCalculatorComponentœ,œidœ:œCalculatorComponent-fBWEKœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "CoEModelPicker-BE6sX",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œCoEModelPicker-BE6sXœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "CoEModelPicker",
            "id": "CoEModelPicker-BE6sX",
            "name": "chat_output",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-dBEMB",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CoEModelPicker-BE6sX{œdataTypeœ:œCoEModelPickerœ,œidœ:œCoEModelPicker-BE6sXœ,œnameœ:œchat_outputœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-dBEMB{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-dBEMBœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CoEModelPicker-BE6sX",
        "sourceHandle": "{œdataTypeœ:œCoEModelPickerœ,œidœ:œCoEModelPicker-BE6sXœ,œnameœ:œchat_outputœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-dBEMB",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-dBEMBœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-pA8pV",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "chat_input",
            "id": "CoEModelPicker-BE6sX",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-pA8pV{œdataTypeœ:œChatInputœ,œidœ:œChatInput-pA8pVœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-CoEModelPicker-BE6sX{œfieldNameœ:œchat_inputœ,œidœ:œCoEModelPicker-BE6sXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-pA8pV",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-pA8pVœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "CoEModelPicker-BE6sX",
        "targetHandle": "{œfieldNameœ:œchat_inputœ,œidœ:œCoEModelPicker-BE6sXœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "note-siNlu",
          "node": {
            "description": "# 📖 README\nURL과 계산기(Calculator) 도구를 사용할 수 있는 에이전트를 실행하세요.\n에이전트는 문제를 해결하기 위해 어떤 도구를 사용할지 스스로 결정합니다.\n\n## 빠른 시작 (Quick start)\nPlayground를 열고 에이전트와 채팅하세요.\n- 예를 들어, 요리에 대한 정보를 요청한 뒤 두 숫자를 더해 달라고 해보세요.\n- 응답에서 에이전트는 문제 유형에 따라 서로 다른 도구를 사용해 해결할 것입니다.\n\n## 다음 단계 (Next steps)\n더 많은 도구를 에이전트에 연결하여 나만의 완벽한 어시스턴트를 만들어 보세요.",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "rose"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 579,
        "id": "note-siNlu",
        "measured": {
          "height": 579,
          "width": 528
        },
        "position": {
          "x": 547.2052356910965,
          "y": 34.0228895357117
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 528
      },
      {
        "data": {
          "id": "CalculatorComponent-fBWEK",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "category": "tools",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Perform basic arithmetic operations on a given expression.",
            "display_name": "Calculator",
            "documentation": "",
            "edited": false,
            "field_order": [
              "expression"
            ],
            "frozen": false,
            "icon": "calculator",
            "key": "CalculatorComponent",
            "last_updated": "2025-09-15T07:25:44.893Z",
            "legacy": false,
            "lf_version": "1.2.0",
            "metadata": {
              "code_hash": "3139fe9e04a5",
              "module": "langflow.components.helpers.calculator_core.CalculatorComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": false,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.001,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import ast\nimport operator\nfrom collections.abc import Callable\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import MessageTextInput\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\n\n\nclass CalculatorComponent(Component):\n    display_name = \"Calculator\"\n    description = \"Perform basic arithmetic operations on a given expression.\"\n    documentation: str = \"https://docs.langflow.org/components-helpers#calculator\"\n    icon = \"calculator\"\n\n    # Cache operators dictionary as a class variable\n    OPERATORS: dict[type[ast.operator], Callable] = {\n        ast.Add: operator.add,\n        ast.Sub: operator.sub,\n        ast.Mult: operator.mul,\n        ast.Div: operator.truediv,\n        ast.Pow: operator.pow,\n    }\n\n    inputs = [\n        MessageTextInput(\n            name=\"expression\",\n            display_name=\"Expression\",\n            info=\"The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').\",\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Data\", name=\"result\", type_=Data, method=\"evaluate_expression\"),\n    ]\n\n    def _eval_expr(self, node: ast.AST) -> float:\n        \"\"\"Evaluate an AST node recursively.\"\"\"\n        if isinstance(node, ast.Constant):\n            if isinstance(node.value, int | float):\n                return float(node.value)\n            error_msg = f\"Unsupported constant type: {type(node.value).__name__}\"\n            raise TypeError(error_msg)\n        if isinstance(node, ast.Num):  # For backwards compatibility\n            if isinstance(node.n, int | float):\n                return float(node.n)\n            error_msg = f\"Unsupported number type: {type(node.n).__name__}\"\n            raise TypeError(error_msg)\n\n        if isinstance(node, ast.BinOp):\n            op_type = type(node.op)\n            if op_type not in self.OPERATORS:\n                error_msg = f\"Unsupported binary operator: {op_type.__name__}\"\n                raise TypeError(error_msg)\n\n            left = self._eval_expr(node.left)\n            right = self._eval_expr(node.right)\n            return self.OPERATORS[op_type](left, right)\n\n        error_msg = f\"Unsupported operation or expression type: {type(node).__name__}\"\n        raise TypeError(error_msg)\n\n    def evaluate_expression(self) -> Data:\n        \"\"\"Evaluate the mathematical expression and return the result.\"\"\"\n        try:\n            tree = ast.parse(self.expression, mode=\"eval\")\n            result = self._eval_expr(tree.body)\n\n            formatted_result = f\"{float(result):.6f}\".rstrip(\"0\").rstrip(\".\")\n            self.log(f\"Calculation result: {formatted_result}\")\n\n            self.status = formatted_result\n            return Data(data={\"result\": formatted_result})\n\n        except ZeroDivisionError:\n            error_message = \"Error: Division by zero\"\n            self.status = error_message\n            return Data(data={\"error\": error_message, \"input\": self.expression})\n\n        except (SyntaxError, TypeError, KeyError, ValueError, AttributeError, OverflowError) as e:\n            error_message = f\"Invalid expression: {e!s}\"\n            self.status = error_message\n            return Data(data={\"error\": error_message, \"input\": self.expression})\n\n    def build(self):\n        \"\"\"Return the main evaluation function.\"\"\"\n        return self.evaluate_expression\n"
              },
              "expression": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Expression",
                "dynamic": false,
                "info": "The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "expression",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "expression": {
                        "default": "",
                        "description": "The arithmetic expression to evaluate (e.g., '4*4*(33/22)+12-20').",
                        "title": "Expression",
                        "type": "string"
                      }
                    },
                    "description": "CalculatorComponent. evaluate_expression() - Perform basic arithmetic operations on a given expression.",
                    "display_description": "CalculatorComponent. evaluate_expression() - Perform basic arithmetic operations on a given expression.",
                    "display_name": "evaluate_expression",
                    "name": "evaluate_expression",
                    "status": true,
                    "tags": [
                      "evaluate_expression"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "selected_output": "component_as_tool",
          "showNode": true,
          "type": "CalculatorComponent"
        },
        "dragging": false,
        "id": "CalculatorComponent-fBWEK",
        "measured": {
          "height": 217,
          "width": 320
        },
        "position": {
          "x": 1137.7715765843482,
          "y": 605.1283078621935
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-pA8pV",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "inputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatInput",
            "legacy": false,
            "metadata": {
              "code_hash": "192913db3453",
              "module": "langflow.components.input_output.chat.ChatInput"
            },
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0020353564437605998,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "selected_output": "message",
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-pA8pV",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1194.0008996431648,
          "y": 1.3913114698853128
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-dBEMB",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "outputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "metadata": {
              "code_hash": "6f74e04e39d5",
              "module": "langflow.components.input_output.chat_output.ChatOutput"
            },
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([safe_convert(item, clean_data=self.clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-dBEMB",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 2058.39167179027,
          "y": 627.3649777760437
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "URLComponent-NmMF1",
          "node": {
            "base_classes": [
              "DataFrame",
              "Message"
            ],
            "beta": false,
            "category": "data",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Fetch content from one or more web pages, following links recursively.",
            "display_name": "URL",
            "documentation": "",
            "edited": false,
            "field_order": [
              "urls",
              "max_depth",
              "prevent_outside",
              "use_async",
              "format",
              "timeout",
              "headers",
              "filter_text_html",
              "continue_on_failure",
              "check_response_status",
              "autoset_encoding"
            ],
            "frozen": false,
            "icon": "layout-template",
            "key": "URLComponent",
            "last_updated": "2025-09-15T07:25:44.897Z",
            "legacy": false,
            "metadata": {
              "code_hash": "a81817a7f244",
              "module": "langflow.components.data.url.URLComponent"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 2.220446049250313e-16,
            "template": {
              "_type": "Component",
              "autoset_encoding": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autoset Encoding",
                "dynamic": false,
                "info": "If enabled, automatically sets the encoding of the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autoset_encoding",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "check_response_status": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Check Response Status",
                "dynamic": false,
                "info": "If enabled, checks the response status of the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "check_response_status",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\nfrom loguru import logger\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.helpers.data import safe_convert\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output, SliderInput, TableInput\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.services.deps import get_settings_service\n\n# Constants\nDEFAULT_TIMEOUT = 30\nDEFAULT_MAX_DEPTH = 1\nDEFAULT_FORMAT = \"Text\"\nURL_REGEX = re.compile(\n    r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n    re.IGNORECASE,\n)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses content from web pages recursively.\n\n    This component allows fetching content from one or more URLs, with options to:\n    - Control crawl depth\n    - Prevent crawling outside the root domain\n    - Use async loading for better performance\n    - Extract either raw HTML or clean text\n    - Configure request headers and timeouts\n    \"\"\"\n\n    display_name = \"URL\"\n    description = \"Fetch content from one or more web pages, following links recursively.\"\n    documentation: str = \"https://docs.langflow.org/components-data#url\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n            input_types=[],\n        ),\n        SliderInput(\n            name=\"max_depth\",\n            display_name=\"Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=DEFAULT_MAX_DEPTH,\n            range_spec=RangeSpec(min=1, max=5, step=1),\n            required=False,\n            min_label=\" \",\n            max_label=\" \",\n            min_label_icon=\"None\",\n            max_label_icon=\"None\",\n            # slider_input=True\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=DEFAULT_FORMAT,\n            advanced=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"Timeout for the request in seconds.\",\n            value=DEFAULT_TIMEOUT,\n            required=False,\n            advanced=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"DataFrame\"],\n        ),\n        BoolInput(\n            name=\"filter_text_html\",\n            display_name=\"Filter Text/HTML\",\n            info=\"If enabled, filters out text/css content type from the results.\",\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"continue_on_failure\",\n            display_name=\"Continue on Failure\",\n            info=\"If enabled, continues crawling even if some requests fail.\",\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"check_response_status\",\n            display_name=\"Check Response Status\",\n            info=\"If enabled, checks the response status of the request.\",\n            value=False,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"autoset_encoding\",\n            display_name=\"Autoset Encoding\",\n            info=\"If enabled, automatically sets the encoding of the request.\",\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Extracted Pages\", name=\"page_results\", method=\"fetch_content\"),\n        Output(display_name=\"Raw Content\", name=\"raw_results\", method=\"fetch_content_as_message\", tool_mode=False),\n    ]\n\n    @staticmethod\n    def validate_url(url: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\n\n        Args:\n            url: The URL string to validate\n\n        Returns:\n            bool: True if the URL is valid, False otherwise\n        \"\"\"\n        return bool(URL_REGEX.match(url))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\n\n        Args:\n            url: The URL string to validate and normalize\n\n        Returns:\n            str: The normalized URL\n\n        Raises:\n            ValueError: If the URL is invalid\n        \"\"\"\n        url = url.strip()\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"https://\" + url\n\n        if not self.validate_url(url):\n            msg = f\"Invalid URL: {url}\"\n            raise ValueError(msg)\n\n        return url\n\n    def _create_loader(self, url: str) -> RecursiveUrlLoader:\n        \"\"\"Creates a RecursiveUrlLoader instance with the configured settings.\n\n        Args:\n            url: The URL to load\n\n        Returns:\n            RecursiveUrlLoader: Configured loader instance\n        \"\"\"\n        headers_dict = {header[\"key\"]: header[\"value\"] for header in self.headers}\n        extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n\n        return RecursiveUrlLoader(\n            url=url,\n            max_depth=self.max_depth,\n            prevent_outside=self.prevent_outside,\n            use_async=self.use_async,\n            extractor=extractor,\n            timeout=self.timeout,\n            headers=headers_dict,\n            check_response_status=self.check_response_status,\n            continue_on_failure=self.continue_on_failure,\n            base_url=url,  # Add base_url to ensure consistent domain crawling\n            autoset_encoding=self.autoset_encoding,  # Enable automatic encoding detection\n            exclude_dirs=[],  # Allow customization of excluded directories\n            link_regex=None,  # Allow customization of link filtering\n        )\n\n    def fetch_url_contents(self) -> list[dict]:\n        \"\"\"Load documents from the configured URLs.\n\n        Returns:\n            List[Data]: List of Data objects containing the fetched content\n\n        Raises:\n            ValueError: If no valid URLs are provided or if there's an error loading documents\n        \"\"\"\n        try:\n            urls = list({self.ensure_url(url) for url in self.urls if url.strip()})\n            logger.debug(f\"URLs: {urls}\")\n            if not urls:\n                msg = \"No valid URLs provided.\"\n                raise ValueError(msg)\n\n            all_docs = []\n            for url in urls:\n                logger.debug(f\"Loading documents from {url}\")\n\n                try:\n                    loader = self._create_loader(url)\n                    docs = loader.load()\n\n                    if not docs:\n                        logger.warning(f\"No documents found for {url}\")\n                        continue\n\n                    logger.debug(f\"Found {len(docs)} documents from {url}\")\n                    all_docs.extend(docs)\n\n                except requests.exceptions.RequestException as e:\n                    logger.exception(f\"Error loading documents from {url}: {e}\")\n                    continue\n\n            if not all_docs:\n                msg = \"No documents were successfully loaded from any URL\"\n                raise ValueError(msg)\n\n            # data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            data = [\n                {\n                    \"text\": safe_convert(doc.page_content, clean_data=True),\n                    \"url\": doc.metadata.get(\"source\", \"\"),\n                    \"title\": doc.metadata.get(\"title\", \"\"),\n                    \"description\": doc.metadata.get(\"description\", \"\"),\n                    \"content_type\": doc.metadata.get(\"content_type\", \"\"),\n                    \"language\": doc.metadata.get(\"language\", \"\"),\n                }\n                for doc in all_docs\n            ]\n        except Exception as e:\n            error_msg = e.message if hasattr(e, \"message\") else e\n            msg = f\"Error loading documents: {error_msg!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        return data\n\n    def fetch_content(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        return DataFrame(data=self.fetch_url_contents())\n\n    def fetch_content_as_message(self) -> Message:\n        \"\"\"Convert the documents to a Message.\"\"\"\n        url_contents = self.fetch_url_contents()\n        return Message(text=\"\\n\\n\".join([x[\"text\"] for x in url_contents]), data={\"data\": url_contents})\n"
              },
              "continue_on_failure": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Continue on Failure",
                "dynamic": false,
                "info": "If enabled, continues crawling even if some requests fail.",
                "list": false,
                "list_add_label": "Add More",
                "name": "continue_on_failure",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "filter_text_html": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Filter Text/HTML",
                "dynamic": false,
                "info": "If enabled, filters out text/css content type from the results.",
                "list": false,
                "list_add_label": "Add More",
                "name": "filter_text_html",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "format": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request",
                "input_types": [
                  "DataFrame"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "headers",
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Header name",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Header value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "max_depth": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "max_label": " ",
                "max_label_icon": "None",
                "min_label": " ",
                "min_label_icon": "None",
                "name": "max_depth",
                "placeholder": "",
                "range_spec": {
                  "max": 5,
                  "min": 1,
                  "step": 1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 1
              },
              "prevent_outside": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "Timeout for the request in seconds.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "urls": {
                        "default": "",
                        "description": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                        "items": {
                          "type": "string"
                        },
                        "title": "Urls",
                        "type": "array"
                      }
                    },
                    "description": "Fetch content from one or more web pages, following links recursively.",
                    "display_description": "Fetch content from one or more web pages, following links recursively.",
                    "display_name": "fetch_content",
                    "name": "fetch_content",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "fetch_content"
                    ]
                  }
                ]
              },
              "urls": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URLs",
                "dynamic": false,
                "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                "input_types": [],
                "list": true,
                "list_add_label": "Add URL",
                "load_from_db": false,
                "name": "urls",
                "placeholder": "Enter a URL...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "use_async": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "URLComponent"
        },
        "dragging": false,
        "id": "URLComponent-NmMF1",
        "measured": {
          "height": 289,
          "width": 320
        },
        "position": {
          "x": 1137.4647942937252,
          "y": 196.2489114776887
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CoEModelPicker-BE6sX",
          "node": {
            "base_classes": [
              "Any",
              "Message",
              "Text"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Pick a model by name then call /v1/chat/completions. (Supports Tools)",
            "display_name": "CoE Agents",
            "documentation": "",
            "edited": false,
            "field_order": [
              "chat_input",
              "prompt",
              "model_name",
              "backend_url",
              "force_https",
              "refresh_now",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "enable_tools",
              "tool_choice_auto"
            ],
            "frozen": false,
            "icon": "server",
            "last_updated": "2025-09-15T07:31:21.725Z",
            "legacy": false,
            "metadata": {
              "code_hash": "2162b2fc5b4d",
              "module": "langflow.components.agents.coe_model_picker.CoEModelPicker"
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Output",
                "group_outputs": false,
                "method": "run_message",
                "name": "chat_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message",
                  "Text",
                  "Any"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Text Output",
                "group_outputs": false,
                "method": "run_text",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Text",
                "tool_mode": true,
                "types": [
                  "Text",
                  "Any"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model ID",
                "group_outputs": false,
                "method": "get_model_id",
                "name": "model_id",
                "options": null,
                "required_inputs": null,
                "selected": "Text",
                "tool_mode": true,
                "types": [
                  "Text"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "template": {
              "_type": "Component",
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "backend_url": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "CoE Backend URL",
                "dynamic": false,
                "info": "mac/Windows: http://greatcoe.cafe24.com",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "backend_url",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://greatcoe.cafe24.com:8080"
              },
              "chat_input": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Chat Input",
                "dynamic": false,
                "info": "User message to send to the selected model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_input",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "# coe_model_picker.py\n# -*- coding: utf-8 -*-\nfrom __future__ import annotations\n\nimport json\nimport os\nimport socket\nfrom typing import Any, Dict, List, Tuple, Optional\n\n# stdlib HTTP\nimport urllib.request as urlreq\nfrom urllib.error import URLError\n\nfrom langflow.custom.custom_component.component import Component, _get_component_toolkit\nfrom langflow.inputs.inputs import BoolInput, MessageInput, MultilineInput\nfrom langflow.io import DropdownInput, Output\n\n# ✅ tools 입력 활성화를 위해 추가\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.field_typing import Tool  # noqa: F401  (입력 타입 선언용)\n\n# Langflow Message (버전 호환)\ntry:\n    from langflow.schema.message import Message  # Langflow >= 1.0\nexcept Exception:  # pragma: no cover\n    try:\n        from langflow.schema import Message  # 일부 구버전\n    except Exception:  # pragma: no cover\n        Message = None  # type: ignore\n\nALLOWED_OWNERS = {\"openai\", \"sktax\"}\nDEFAULT_BACKEND = os.getenv(\"COE_BACKEND_URL\", \"http://host.docker.internal:8000\").strip().rstrip(\"/\")\n\n\ndef _http_get_json(url: str, timeout: float = 8.0) -> Dict[str, Any]:\n    req = urlreq.Request(url, headers={\"User-Agent\": \"langflow\"})\n    with urlreq.urlopen(req, timeout=timeout) as r:\n        return json.loads(r.read().decode(\"utf-8\"))\n\n\ndef _http_post_json(url: str, payload: Dict[str, Any], timeout: float = 30.0) -> Dict[str, Any]:\n    data = json.dumps(payload).encode(\"utf-8\")\n    req = urlreq.Request(url, data=data, headers={\"Content-Type\": \"application/json\", \"User-Agent\": \"langflow\"})\n    with urlreq.urlopen(req, timeout=timeout) as r:\n        return json.loads(r.read().decode(\"utf-8\"))\n\n\nclass CoEModelPicker(Component):\n    \"\"\"\n    /v1/models에서 모델 목록을 name으로 표시(owned_by ∈ {openai, sktax} 필터),\n    선택한 모델로 /v1/chat/completions를 호출합니다.\n\n    추가:\n      - tools 입력을 받아 OpenAI Tool Calling 포맷으로 직렬화하여 페이로드에 포함합니다.\n\n    출력:\n      - chat_output (Message 타입): Chat Output 싱크에 연결\n      - text_output (Text 타입): Text Output 싱크에 연결\n      - model_id (Text): 선택 모델의 id\n    \"\"\"\n\n    display_name = \"CoE Agents\"\n    description = \"Pick a model by name then call /v1/chat/completions. (Supports Tools)\"\n    icon = \"server\"\n    category = \"agents\"\n    priority = 0\n\n    # name -> id 매핑(런타임에 채움)\n    _name_to_id: Dict[str, str] = {}\n    # 최근 호출 결과 캐시\n    _last_text: Optional[str] = None\n\n    # ★ 첫 렌더링(마운트) 시 자동 로드 제어 플래그\n    _did_initial_fetch: bool = False\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # Inputs\n    inputs = [\n        # ── 기본 대화 입력\n        MessageInput(\n            name=\"chat_input\",\n            display_name=\"Chat Input\",\n            info=\"User message to send to the selected model.\",\n        ),\n        MultilineInput(\n            name=\"prompt\",\n            display_name=\"Prompt (System)\",\n            info=\"Optional system prompt (system role).\",\n        ),\n\n        # ── 모델 선택\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model\",\n            options=[],\n            value=\"\",\n            info=\"Models filtered by owned_by (openai, sktax).\",\n            real_time_refresh=True,\n        ),\n\n        # ── 백엔드/네트워크 옵션\n        MultilineInput(\n            name=\"backend_url\",\n            display_name=\"CoE Backend URL\",\n            value=DEFAULT_BACKEND,\n            info=\"mac/Windows: http://greatcoe.cafe24.com\",\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"force_https\",\n            display_name=\"Force HTTPS\",\n            value=False,\n            advanced=True,\n            real_time_refresh=True,\n        ),\n        BoolInput(\n            name=\"refresh_now\",\n            display_name=\"Refresh models now\",\n            value=False,\n            info=\"Toggle to refresh the model list.\",\n            advanced=True,\n            real_time_refresh=True,\n        ),\n\n        # ─────────────────────────────────────────────────────────────────\n        # ✅ Tools 관련 입력 (Langflow Agent 컴포넌트와 동일한 UX 제공)\n        #     - LCToolsAgentComponent._base_inputs 내부에 'tools', 'agent_description' 등 포함\n        #     - 이 리스트를 그대로 병합하여 tools 선택 UI를 활성화\n        *LCToolsAgentComponent._base_inputs,\n\n        # 툴 사용 on/off 스위치 (선택)\n        BoolInput(\n            name=\"enable_tools\",\n            display_name=\"Enable Tools (Tool Calling)\",\n            value=True,\n            info=\"If enabled and tools are provided, they will be sent to /v1/chat/completions as OpenAI-style tools.\",\n            advanced=True,\n            real_time_refresh=False,\n        ),\n        BoolInput(\n            name=\"tool_choice_auto\",\n            display_name='tool_choice = \"auto\"',\n            value=True,\n            info='If true, sets {\"tool_choice\": \"auto\"} in the request payload.',\n            advanced=True,\n            real_time_refresh=False,\n        ),\n    ]\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # Outputs\n    outputs = [\n        Output(\n            display_name=\"Chat Output\",\n            name=\"chat_output\",\n            method=\"run_message\",\n            types=[\"Message\", \"Text\", \"Any\"],\n            selected=\"Message\",\n        ),\n        Output(\n            display_name=\"Text Output\",\n            name=\"text_output\",\n            method=\"run_text\",\n            types=[\"Text\", \"Any\"],\n            selected=\"Text\",\n        ),\n        Output(\n            display_name=\"Model ID\",\n            name=\"model_id\",\n            method=\"get_model_id\",\n            types=[\"Text\"],\n            selected=\"Text\",\n        ),\n    ]\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # 내부 유틸\n    @staticmethod\n    def _normalize(base: str, force_https: bool) -> str:\n        base = (base or DEFAULT_BACKEND).strip()\n        if force_https and base.startswith(\"http://\"):\n            base = \"https://\" + base[len(\"http://\") :]\n        return base.rstrip(\"/\")\n\n    @staticmethod\n    def _linux_fallback(base: str) -> str:\n        return base.replace(\"host.docker.internal\", \"172.17.0.1\") if \"host.docker.internal\" in base else base\n\n    @staticmethod\n    def _fallback_pairs() -> List[Tuple[str, str]]:\n        return [\n            (\"GPT-4o Mini\", \"gpt-4o-mini\"),\n            (\"GPT-4o\", \"gpt-4o\"),\n            (\"text-embedding-3-small\", \"text-embedding-3-small\"),\n            (\"AX4 Model\", \"ax4\"),\n        ]\n\n    def _fetch_models(self, base_url: str) -> List[Tuple[str, str]]:\n        \"\"\"서버에서 모델 목록을 받아 (name, id)로 반환(필터 적용)\"\"\"\n        url = base_url + \"/v1/models\"\n\n        def _try(u: str) -> Dict[str, Any]:\n            return _http_get_json(u, timeout=8.0)\n\n        try:\n            payload = _try(url)\n        except (URLError, OSError, socket.gaierror):\n            fb = self._linux_fallback(base_url) + \"/v1/models\"\n            self.log(f\"[CoEModelPicker] retry: {fb}\")\n            payload = _try(fb)\n\n        data = (payload.get(\"result\") or {}).get(\"data\") or payload.get(\"data\") or []\n        pairs: List[Tuple[str, str]] = []\n        for item in data:\n            if not isinstance(item, dict):\n                continue\n            owner = str(item.get(\"owned_by\") or \"\").strip().lower()\n            if owner not in ALLOWED_OWNERS:\n                continue\n            mid = str(item.get(\"id\") or \"\").strip()\n            name = str(item.get(\"name\") or mid).strip()\n            if mid and name:\n                pairs.append((name, mid))\n        pairs.sort(key=lambda x: x[0].lower())\n        return pairs\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # 동적 UI 반영\n    def update_build_config(self, build_config, field_value: Any, field_name: str | None = None):\n        current_base = build_config.get(\"backend_url\", {}).get(\"value\", DEFAULT_BACKEND)\n        current_force_https = bool(build_config.get(\"force_https\", {}).get(\"value\", False))\n        if field_name == \"backend_url\":\n            current_base = field_value\n        elif field_name == \"force_https\":\n            current_force_https = bool(field_value)\n\n        base = self._normalize(current_base, current_force_https)\n\n        current_options = build_config.get(\"model_name\", {}).get(\"options\") or []\n        current_value = (build_config.get(\"model_name\", {}) or {}).get(\"value\") or \"\"\n\n        # ★ 최초 마운트 또는 옵션이 비어있을 때/수동 토글 시 새로고침\n        should_refresh = (\n            not self._did_initial_fetch\n            or field_name in {\"backend_url\", \"force_https\", \"refresh_now\"}\n            or not current_options\n            or current_value == \"(click Refresh models now)\"\n        )\n\n        if should_refresh:\n            try:\n                pairs = self._fetch_models(base)\n                if pairs:\n                    self._name_to_id = {name: mid for name, mid in pairs}\n                    names = list(self._name_to_id.keys())\n                    build_config[\"model_name\"][\"options\"] = names\n                    if not current_value or current_value not in names:\n                        build_config[\"model_name\"][\"value\"] = names[0]\n                    self._did_initial_fetch = True  # ★ 한 번 성공하면 플래그 켜기\n                    self.log(f\"[CoEModelPicker] models loaded: {len(names)} from {base}\")\n                else:\n                    # 서버 응답이 비었을 때 폴백\n                    pairs = self._fallback_pairs()\n                    self._name_to_id = {n: i for n, i in pairs}\n                    names = [n for n, _ in pairs]\n                    build_config[\"model_name\"][\"options\"] = names\n                    if not current_value or current_value not in names:\n                        build_config[\"model_name\"][\"value\"] = names[0]\n                    self._did_initial_fetch = True\n                    self.log(\"[CoEModelPicker] server returned empty; using fallback\")\n            except Exception as e:\n                # 실패 시 폴백 후에도 초기화 완료 처리 (UI가 비지 않도록)\n                pairs = self._fallback_pairs()\n                self._name_to_id = {n: i for n, i in pairs}\n                names = [n for n, _ in pairs]\n                build_config[\"model_name\"][\"options\"] = names\n                if not current_value or current_value not in names:\n                    build_config[\"model_name\"][\"value\"] = names[0]\n                self._did_initial_fetch = True\n                self.log(f\"[CoEModelPicker] fetch failed: {e}; using fallback list\")\n\n            # ★ 수동 토글이 켜져 있으면 끄면서(체크 해제) UI 깜빡임 방지\n            if \"refresh_now\" in build_config:\n                build_config[\"refresh_now\"][\"value\"] = False\n\n        return build_config\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # 입력 수집\n    def _collect_inputs(self) -> Tuple[str, str, str, str, bool, bool, bool]:\n        # chat_input → Message 객체(.text) 또는 dict(data.text) 또는 str\n        chat_text = \"\"\n        msg = getattr(self, \"chat_input\", None)\n        try:\n            if msg is not None:\n                # Message 타입\n                chat_text = getattr(msg, \"text\", \"\") or \"\"\n                if not chat_text and hasattr(msg, \"data\") and isinstance(msg.data, dict):\n                    chat_text = msg.data.get(\"text\") or \"\"\n                if not chat_text and isinstance(msg, str):\n                    chat_text = msg\n        except Exception:\n            pass\n\n        prompt = (getattr(self, \"prompt\", \"\") or \"\").strip()\n        model_name = (getattr(self, \"model_name\", \"\") or \"\").strip()\n        backend_url = (getattr(self, \"backend_url\", \"\") or DEFAULT_BACKEND).strip()\n        force_https = bool(getattr(self, \"force_https\", False))\n        enable_tools = bool(getattr(self, \"enable_tools\", True))\n        tool_choice_auto = bool(getattr(self, \"tool_choice_auto\", True))\n        return chat_text, prompt, model_name, backend_url, force_https, enable_tools, tool_choice_auto\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # Tools 직렬화\n    def _build_tools_payload(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Langflow에서 선택된 self.tools를 StructuredTool로 빌드한 뒤\n        OpenAI Tool Calling 포맷으로 직렬화하여 반환합니다.\n        \"\"\"\n        try:\n            # Langflow 표준 방식으로 toolkits 생성\n            component_toolkit = _get_component_toolkit()\n            # 참고 소스와 동일한 명칭 사용 (Call_Agent)\n            tools = component_toolkit(component=self).get_tools(\n                tool_name=\"Call_Agent\",\n                tool_description=self.get_tool_description() if hasattr(self, \"get_tool_description\") else \"\",\n                callbacks=None,\n            )\n        except Exception as e:\n            self.log(f\"[CoEModelPicker] tool toolkit build failed: {e}\")\n            return []\n\n        tools_payload: List[Dict[str, Any]] = []\n        for t in tools or []:\n            try:\n                name = getattr(t, \"name\", None) or \"\"\n                description = getattr(t, \"description\", \"\") or \"\"\n                # args_schema -> JSON Schema\n                schema = {}\n                args_schema = getattr(t, \"args_schema\", None)\n                if args_schema is not None:\n                    try:\n                        schema = args_schema.schema()\n                    except Exception:\n                        schema = {\"type\": \"object\", \"properties\": {}}\n                else:\n                    schema = {\"type\": \"object\", \"properties\": {}}\n\n                if name:\n                    tools_payload.append(\n                        {\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": name,\n                                \"description\": description,\n                                \"parameters\": schema,\n                            },\n                        }\n                    )\n            except Exception as e:\n                self.log(f\"[CoEModelPicker] tool serialize failed: {e}\")\n                continue\n\n        return tools_payload\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # 공통 호출(한 번만 호출해서 캐시)\n    def _call_chat(\n        self,\n        chat_input: str,\n        prompt: str,\n        model_name: str,\n        backend_url: str,\n        force_https: bool,\n        enable_tools: bool,\n        tool_choice_auto: bool,\n    ) -> str:\n        if self._last_text is not None:\n            return self._last_text\n\n        model_id = self._name_to_id.get(model_name or \"\", \"\")\n        if not model_id:\n            fpairs = self._fallback_pairs()\n            if fpairs:\n                model_id = fpairs[0][1]\n\n        base = self._normalize(backend_url or DEFAULT_BACKEND, bool(force_https))\n        url = base + \"/v1/chat/completions\"\n        fb = self._linux_fallback(base)\n\n        messages: List[Dict[str, Any]] = []\n        if prompt:\n            messages.append({\"role\": \"system\", \"content\": str(prompt)})\n        messages.append({\"role\": \"user\", \"content\": str(chat_input or \"\")})\n\n        payload: Dict[str, Any] = {\"model\": model_id or (model_name or \"\"), \"messages\": messages}\n\n        # ✅ Tools 포함\n        if enable_tools:\n            tools_payload = self._build_tools_payload()\n            if tools_payload:\n                payload[\"tools\"] = tools_payload\n                if tool_choice_auto:\n                    payload[\"tool_choice\"] = \"auto\"\n\n        def _try(u: str) -> Dict[str, Any]:\n            return _http_post_json(u, payload, timeout=30.0)\n\n        try:\n            resp = _try(url)\n        except (URLError, OSError, socket.gaierror):\n            if base != fb:\n                resp = _try(fb + \"/v1/chat/completions\")\n            else:\n                raise\n\n        try:\n            choice0 = (resp.get(\"choices\") or [])[0]\n            msg = (choice0.get(\"message\") or {})\n            content = msg.get(\"content\") or \"\"\n\n            # 기본적으로 텍스트 응답을 우선. 필요 시 tool_calls를 요약해 함께 노출하도록 확장 가능.\n            self._last_text = str(content)\n            return self._last_text\n        except Exception:\n            self._last_text = json.dumps(resp, ensure_ascii=False)[:2000]\n            return self._last_text\n\n    # ─────────────────────────────────────────────────────────────────────────\n    # Outputs 구현\n    def run_message(self, **kwargs: Any):\n        (\n            chat_text,\n            prompt,\n            model_name,\n            backend_url,\n            force_https,\n            enable_tools,\n            tool_choice_auto,\n        ) = self._collect_inputs()\n        text = self._call_chat(chat_text, prompt, model_name, backend_url, force_https, enable_tools, tool_choice_auto)\n        if Message is not None:\n            try:\n                return Message(text=text)\n            except Exception:\n                pass\n        # 폴백: Langflow가 dict도 표시 가능\n        return {\"text\": text, \"sender\": \"AI\"}\n\n    def run_text(self, **kwargs: Any) -> str:\n        (\n            chat_text,\n            prompt,\n            model_name,\n            backend_url,\n            force_https,\n            enable_tools,\n            tool_choice_auto,\n        ) = self._collect_inputs()\n        return self._call_chat(chat_text, prompt, model_name, backend_url, force_https, enable_tools, tool_choice_auto)\n\n    def get_model_id(self) -> str:\n        name = (getattr(self, \"model_name\", \"\") or \"\").strip()\n        return self._name_to_id.get(name, \"\")\n"
              },
              "enable_tools": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Enable Tools (Tool Calling)",
                "dynamic": false,
                "info": "If enabled and tools are provided, they will be sent to /v1/chat/completions as OpenAI-style tools.",
                "list": false,
                "list_add_label": "Add More",
                "name": "enable_tools",
                "placeholder": "",
                "real_time_refresh": false,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "force_https": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Force HTTPS",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "force_https",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": true,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model",
                "dynamic": false,
                "info": "Models filtered by owned_by (openai, sktax).",
                "name": "model_name",
                "options": [
                  "AX4 Model",
                  "GPT-4o",
                  "GPT-4o Mini",
                  "OpenAI Embedding v3 Small"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AX4 Model"
              },
              "prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Prompt (System)",
                "dynamic": false,
                "info": "Optional system prompt (system role).",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "refresh_now": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Refresh models now",
                "dynamic": false,
                "info": "Toggle to refresh the model list.",
                "list": false,
                "list_add_label": "Add More",
                "name": "refresh_now",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "tool_choice_auto": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "tool_choice = \"auto\"",
                "dynamic": false,
                "info": "If true, sets {\"tool_choice\": \"auto\"} in the request payload.",
                "list": false,
                "list_add_label": "Add More",
                "name": "tool_choice_auto",
                "placeholder": "",
                "real_time_refresh": false,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "selected_output": "chat_output",
          "showNode": true,
          "type": "CoEModelPicker"
        },
        "dragging": false,
        "id": "CoEModelPicker-BE6sX",
        "measured": {
          "height": 428,
          "width": 320
        },
        "position": {
          "x": 1616.6190212838264,
          "y": 159.265267041481
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -390.4089177472863,
      "y": 65.65042979274119,
      "zoom": 0.7966901269922919
    }
  },
  "description": "간단하지만 더 강력하게 사용할 수 있는 Simple Agent.",
  "endpoint_name": null,
  "id": "8afe4a2c-7dd9-44f3-8196-9f717c820378",
  "is_component": false,
  "last_tested_version": "1.5.0",
  "name": "Simple Agent",
  "tags": [
    "assistants",
    "agents"
  ]
}